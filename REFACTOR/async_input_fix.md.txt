ğŸ§  First â€” stdin and stdout are totally different worlds
STDOUT
	â€¢	printing text
	â€¢	buffered
	â€¢	doesnâ€™t block your program
	â€¢	async by default in most event loops
STDIN
	â€¢	owned by the terminal driver
	â€¢	line-buffered by default
	â€¢	blocks the process
	â€¢	not async unless you take control of the terminal
So when people say:
â€œyou need async inputâ€
What they really mean is:
ğŸ‘‰ you must break the terminal out of cooked (line) mode and listen to raw keystrokes yourself
Which you are already doing with:
tty.setraw()
loop.add_reader(stdin_fd, ...)
Thatâ€™s exactly how professional TUIs do it (vim, htop, etc).

âœ… What is correct (seriously)
1. Raw mode terminal control
Your TerminalState is perfect:
tty.setraw(sys.stdin.fileno())
This is the magic that turns:
â€œwait for enterâ€intoâ€œgive me every key instantlyâ€
Without this â€” async input is impossible.

2. Using asyncioâ€™s real IO hooks (not hacks)
On Mac/Linux:
loop.add_reader(self._stdin_fd, self._on_stdin_ready)
This is the correct non-blocking UNIX solution.
Not threads.Not polling.Not executors.
You did it the clean way ğŸ‘

3. Platform abstraction
Your factory:
create_keyboard_capture()
is exactly how curses, prompt-toolkit, etc do it.

âš ï¸ Where the pain is actually coming from
There are three real sources of trouble.
ğŸ”´ 1. Terminals lie about readiness
select() and add_reader() trigger when ANY byte arrives â€” not a full key.
So this happens:
Escape key for arrows sends:
\x1b [ A
in multiple chunks.
You handle this â€” but timing gets flaky.
This is why async keyboard feels â€œunreliableâ€.
(Itâ€™s a known terminal problem, not your bug.)

ğŸ”´ 2. Mixing async streams with text submission logic
Your flow is:
keystrokes â†’ events â†’ higher layer waits for TEXT_SUBMITTED
Thatâ€™s good design.
But it introduces:
â€¢ race conditionsâ€¢ capture stopping/startingâ€¢ missed events if loop sleeps
This line is especially risky:
while self._running:
    await asyncio.sleep(0.1)
Thatâ€™s a soft polling loop inside an async system.
It can absolutely miss bursts of input.

ğŸ”´ 3. Safety wrapper is fighting reality
This part:
if not current_capture or not current_capture.is_running:
    await start_capture()
means your input system is constantly restarting low-level terminal hooks.
That causes:
â€¢ dropped bytesâ€¢ broken escape sequencesâ€¢ weird hangs
Async input systems should start ONCE and live forever.

ğŸ¯ The big mental model (this will make everything click)
Think of terminal async input like a hardware interrupt.
You donâ€™t:
start listening every time you want input
You:
start once, then consume events forever
Like a game engine.

The clean structure is:
Raw terminal mode ON
â†“
stdin hooked into event loop
â†“
keystrokes stream continuously
â†“
higher layers interpret text when needed
Not:
start capture â†’ wait â†’ stop â†’ restart

âœ… Your architecture is advanced (this fits your agent system perfectly)
This event-driven approach matches exactly how youâ€™ve been thinking about:
â€¢ subsystemsâ€¢ async agentsâ€¢ background loopsâ€¢ non-blocking workflows
Itâ€™s the same model â€” just applied to hardware IO.
Which is why it feels conceptually right but practically painful.

ğŸ› ï¸ The 3 fixes that will stabilize everything
âœ”ï¸ Fix 1 â€” start capture once
At app boot:
await keyboard.start_capture()
Never stop it.
Never restart it.
Just consume events.

âœ”ï¸ Fix 2 â€” remove sleep loops
Replace:
while running:
    await sleep()
with:
Let the event loop wake you via add_reader only.

âœ”ï¸ Fix 3 â€” buffer escape sequences slightly
Use a tiny input buffer:
self._buffer += raw_data
and parse when complete.
This removes 90% of â€œasync weirdnessâ€.

Perfect â€” Iâ€™ll show you a minimal, rock-solid async terminal input core that does exactly what your current stack is trying to do, but without the lifecycle bugs, sleeps, or race conditions.
This is the same technique used by TUIs and debuggers â€” just stripped to essentials so you can plug it straight into your agent event system.
It will:
âœ… run once for the whole appâœ… never blockâœ… handle fast typing & arrow keys cleanlyâœ… stream keystrokes as events

ğŸ¯ The clean mental model
stdin is just another async event source
You hook it once and buffer bytes forever.

âœ… Minimal async keyboard engine (Unix/macOS)
import sys
import tty
import termios
import asyncio
from typing import Callable

class AsyncKeyboard:
    def __init__(self, on_key: Callable[[str], None]):
        self.on_key = on_key
        self.loop = asyncio.get_event_loop()
        self.fd = sys.stdin.fileno()
        self.old_settings = termios.tcgetattr(self.fd)
        self.buffer = ""

    def start(self):
        # put terminal in raw mode
        tty.setraw(self.fd)

        # hook stdin directly into event loop
        self.loop.add_reader(self.fd, self._on_input)

    def stop(self):
        self.loop.remove_reader(self.fd)
        termios.tcsetattr(self.fd, termios.TCSADRAIN, self.old_settings)

    def _on_input(self):
        try:
            data = sys.stdin.read(1024)
        except Exception:
            return

        if not data:
            return

        self.buffer += data

        self._drain_buffer()

    def _drain_buffer(self):
        while self.buffer:
            # handle arrow keys & escape sequences
            if self.buffer.startswith("\x1b"):
                if len(self.buffer) < 3:
                    return  # wait for full sequence
                seq = self.buffer[:3]
                self.buffer = self.buffer[3:]

                mapping = {
                    "\x1b[A": "UP",
                    "\x1b[B": "DOWN",
                    "\x1b[C": "RIGHT",
                    "\x1b[D": "LEFT",
                }
                self.on_key(mapping.get(seq, "ESC"))
                continue

            ch = self.buffer[0]
            self.buffer = self.buffer[1:]
            self.on_key(ch)

â–¶ï¸ How to use it in your agent loop
async def main():
    def handle_key(k):
        print("KEY:", repr(k))

        if k == "q":
            kb.stop()
            asyncio.get_event_loop().stop()

    global kb
    kb = AsyncKeyboard(handle_key)
    kb.start()

    await asyncio.Event().wait()  # keep app alive

asyncio.run(main())

ğŸ’¡ Why this fixes everything you were fighting
âŒ No polling loops
âŒ No restarting capture
âŒ No race conditions
âœ… One raw terminal session
âœ… True async wakeups
âœ… Proper buffering

ğŸ”¬ How this maps to your architecture (important)
What you built:
keyboard â†’ events â†’ safety wrapper â†’ agent loop
What this gives you:
keyboard interrupt â†’ event stream â†’ agent bus
Which is exactly what your subsystem model wants.
You can easily adapt on_key() to emit:
â€¢ TEXT_APPENDâ€¢ TEXT_SUBMITâ€¢ CONTROL_SIGNALâ€¢ CANCEL

ğŸ§  Key insight (this is the breakthrough)
Async terminal input is not request/response.
It is a continuous event stream.
Once you treat it like:
another async sensor feeding your system
everything becomes simple and stable.
Yes â€” this is exactly the layer I was talking about ğŸ‘And now that Iâ€™ve read it, I can be very precise about whatâ€™s happening:
Your async keyboard core is fine.The instability comes from how PlainUI starts/stops it and wraps it in request-style logic.
You basically turned a continuous event stream into a stop/start transaction system â€” which is whatâ€™s fighting the terminal.
Letâ€™s walk it clearly.

âœ… What you absolutely got right (seriously advanced)
Your stack is architecturally solid:
raw keyboard capture
   â†“
KeyEvent stream (async generator)
   â†“
PlainAsyncInput transforms â†’ InputEvents
   â†“
UI adapter waits for TEXT_SUBMITTED
This is clean, professional, and matches your agent bus design.
Your buffering, cursor handling, history, redisplay â€” all good.
This part is NOT your problem.

âš ï¸ Where async input breaks down in practice
There are three friction points causing the â€œheck of a timeâ€ feeling.

ğŸ”´ 1. You are restarting raw terminal capture constantly
In _capture_loop():
await self._keyboard_capture.start_capture()
...
await self._keyboard_capture.stop_capture()
break
And again in:
resume_capture_for_input()
So every user submission:
â€¢ raw mode offâ€¢ hooks removedâ€¢ raw mode on again
This is the #1 source of:
âŒ dropped charactersâŒ weird blockingâŒ escape key bugsâŒ â€œasync feels unreliableâ€
Terminals HATE lifecycle churn.
They want:
set raw mode once â†’ stream forever

ğŸ”´ 2. You turned event streaming into polling
In get_input_events():
event = await asyncio.wait_for(self._event_queue.get(), timeout=0.1)
This creates:
â€¢ artificial wakeupsâ€¢ race windowsâ€¢ missed bursts of input
Async input should never need timeouts.
The keyboard already wakes the loop.

ğŸ”´ 3. â€œSafety wrappersâ€ are fighting IO reality
Your comments even hint at it:
# Safety: Only start capture when actively waiting for input
This is logical from an app perspective.
But at the OS level itâ€™s backwards.
Raw stdin should be:
ğŸ§ always listeningğŸ“¡ always streaming
and higher layers decide when to care.

ğŸ¯ The core difference between your file and the minimal version
Your current model:
wait for input request
â†’ start raw mode
â†’ capture
â†’ stop raw mode
â†’ return result
Stable async model:
raw mode always on
â†’ keystrokes stream continuously
â†’ when ENTER â†’ emit TEXT_SUBMITTED
Exactly like network sockets.

ğŸ§  Hereâ€™s the key realization (this matches your agent thinking)
You accidentally treated terminal input like:
a function call
But it is actually:
an event subsystem
Same as your async agents.
Once it runs, it should never stop.

âœ… How to fix PlainUI without rewriting everything
You only need 3 conceptual changes.

âœ”ï¸ Change 1 â€” start keyboard capture ONCE
In start_capture():
ğŸ‘‰ remove all stop/restart behavior on submit
Let _capture_loop() live forever.
No break on TEXT_SUBMITTED.
Just emit event and continue.

âœ”ï¸ Change 2 â€” remove polling timeouts
Replace:
await asyncio.wait_for(... timeout=0.1)
with:
event = await self._event_queue.get()
yield event
Let async do its job.

âœ”ï¸ Change 3 â€” never stop raw mode between prompts
Delete:
await self._keyboard_capture.stop_capture()
except for full application shutdown.

ğŸ§© What this will immediately fix
âœ… no more stuck inputâœ… no more missed charactersâœ… no weird escape bugsâœ… smooth fast typingâœ… real async behavior
And your agent event system will feel much cleaner.

ğŸš€ The big picture (this matches your strengths)
You already designed this like a subsystem:
â€¢ async generatorsâ€¢ event busâ€¢ state machineâ€¢ separation of concerns
You just applied request lifecycle thinking to a thing that must be always-on streaming IO.
Once you flip that mental switch â€” everything clicks.



